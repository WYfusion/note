### 路由选择顺序：
首选路由：最短路径。即，图论中的端间最短径。可分为两种情况：
- **指定端到其他各端**的最短径——**D**算法(Dijkstra算法)
- **任意两端间**的最短径——**F**算法(Warshall-Floyd算法)
**迂回路由**：次短径或可用径。

## **D**算法(Dijkstra算法,迪杰斯特拉算法)
D算法为$O(n^2)$
[图-最短路径-Dijkstra(迪杰斯特拉)算法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1uT4y1p7Jy/?spm_id_from=333.337.search-card.all.click&vd_source=1574bd9421ca96a2f458f57838315ec6)
![[Pasted image 20250617153832.png|800]]
![[Pasted image 20250617160217.png|800]]
1. **初始化**：
    - 设源点 $u$，集合 $N' = \{u\}$（已确定最短路径的顶点集合）。
    - 距离数组 D：$D(u) = 0$，其他顶点 x 的 $D(d) = \infty$（若 x 与 u 相邻，$D(x) = c(u, x)$，c 为边权）。
2. **循环迭代（直到 $N'$ 包含所有顶点）**：
    - **步骤 1：选择当前最短距离的顶点** 在 $N'$ 外的顶点中，找到 $D(m)$ 最小的顶点 $w$，将其加入 $N'$（确定 $u$ 到 $w$ 的最短路径，因边权非负，后续无需更新）。
    - **步骤 2：更新邻接顶点的距离** 对于 $w$ 的所有邻接顶点 d（不在 $N'$ 中），更新距离：$D(d) = \min(D(d), D(m) + c(m, d))$（新路径 $u \to w \to y$ 可能更短）。
注意若代价比之前的大，则不更新，代价比之前的小则更新。

## Warshall-Floyd算法(F算法,弗洛伊德算法)
F算法时间复杂度为$O(n^3)$
#### 初始化为权重矩阵
![[Pasted image 20250617214840.png|800]]
可以用所选节点**定位的形式**找最小的
![[Pasted image 20250617181958.png|800]]

![[Pasted image 20250617182030.png|800]]
![[Pasted image 20250617182052.png|800]]
![[Pasted image 20250617182223.png|800]]
![[Pasted image 20250617182311.png|800]]
![[Pasted image 20250617182336.png|800]]
![[Pasted image 20250617182359.png|800]]
