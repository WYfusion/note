# 多假设追踪

## 1. 概述

**多假设追踪 (Multiple Hypothesis Tracking, MHT)** 处理多目标追踪中的数据关联不确定性问题。

---

## 2. 数据关联问题

### 2.1 问题描述

在多说话人场景中：
- 多个观测来自不同说话人
- 观测与轨迹的对应关系未知
- 存在虚警和漏检

### 2.2 关联假设

每个观测可能：
1. 来自已有轨迹
2. 来自新目标
3. 是虚警

---

## 3. MHT算法

### 3.1 假设树

```
t=0:  Track 1
       |
t=1:  ├─ Obs A → Track 1
       └─ Obs B → New Track 2
       |
t=2:  ├─ Obs C → Track 1, Obs D → Track 2
       └─ Obs C → Track 2, Obs D → Track 1
```

### 3.2 假设评分

$$S_h = \sum_{t} \log p(\mathbf{z}_t | \mathbf{x}_t, h)$$

### 3.3 假设剪枝

保留得分最高的N个假设。

---

## 4. 简化方法

### 4.1 全局最近邻 (GNN)

选择全局最优关联：
$$\max \sum_{i,j} s_{ij} a_{ij}$$

其中 $a_{ij} \in \{0,1\}$ 表示关联。

### 4.2 联合概率数据关联 (JPDA)

计算每个关联的概率：
$$\beta_{ij} = P(\text{obs } j \text{ from track } i | \mathbf{Z})$$

状态更新使用加权和。

---

## 5. 实现要点

```python
class MultiHypothesisTracker:
    """多假设追踪器"""
    
    def __init__(self, max_hypotheses=10):
        self.hypotheses = []
        self.max_hypotheses = max_hypotheses
    
    def predict(self):
        """预测所有假设"""
        for h in self.hypotheses:
            h.predict()
    
    def update(self, observations):
        """生成新假设"""
        new_hypotheses = []
        
        for h in self.hypotheses:
            # 为每个观测生成关联假设
            for obs in observations:
                new_h = h.copy()
                new_h.associate(obs)
                new_hypotheses.append(new_h)
            
            # 漏检假设
            new_h = h.copy()
            new_h.miss_detection()
            new_hypotheses.append(new_h)
        
        # 剪枝
        self.hypotheses = self.prune(new_hypotheses)
    
    def prune(self, hypotheses):
        """保留最佳假设"""
        scores = [h.score() for h in hypotheses]
        indices = np.argsort(scores)[-self.max_hypotheses:]
        return [hypotheses[i] for i in indices]
```

---

## 6. 应用场景

- 多说话人会议
- 重叠语音
- 说话人进出场景

---

## 参考文献

1. Reid, D. (1979). "An algorithm for tracking multiple targets." IEEE TAC.

2. Blackman, S. S. (2004). "Multiple hypothesis tracking for multiple target tracking." IEEE AES Magazine.
