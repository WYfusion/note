# 粒子滤波

## 1. 概述

**粒子滤波 (Particle Filter, PF)** 使用蒙特卡洛方法近似后验分布，可处理任意非线性非高斯系统。

---

## 2. 基本思想

### 2.1 粒子表示

用加权粒子集近似后验分布：

$$p(\mathbf{x}_t | \mathbf{z}_{1:t}) \approx \sum_{i=1}^{N} w_t^{(i)} \delta(\mathbf{x}_t - \mathbf{x}_t^{(i)})$$

其中：
- $\mathbf{x}_t^{(i)}$：第$i$个粒子
- $w_t^{(i)}$：粒子权重
- $N$：粒子数量

### 2.2 重要性采样

从提议分布 $q(\mathbf{x}_t | \mathbf{x}_{t-1}, \mathbf{z}_t)$ 采样，权重为：

$$w_t^{(i)} \propto \frac{p(\mathbf{z}_t | \mathbf{x}_t^{(i)}) p(\mathbf{x}_t^{(i)} | \mathbf{x}_{t-1}^{(i)})}{q(\mathbf{x}_t^{(i)} | \mathbf{x}_{t-1}^{(i)}, \mathbf{z}_t)}$$

---

## 3. SIR粒子滤波

### 3.1 算法步骤

**采样 (Sample)**：
从状态转移分布采样：
$$\mathbf{x}_t^{(i)} \sim p(\mathbf{x}_t | \mathbf{x}_{t-1}^{(i)})$$

**重要性权重 (Importance)**：
$$w_t^{(i)} \propto w_{t-1}^{(i)} p(\mathbf{z}_t | \mathbf{x}_t^{(i)})$$

**重采样 (Resample)**：
根据权重重采样粒子

### 3.2 完整算法

```
输入: z_1, ..., z_T, N (粒子数)
输出: x̂_1, ..., x̂_T

初始化:
  对于 i = 1, ..., N:
    x_0^(i) ~ p(x_0)
    w_0^(i) = 1/N

对于 t = 1, ..., T:
  # 采样
  对于 i = 1, ..., N:
    x_t^(i) ~ p(x_t | x_{t-1}^(i))
  
  # 权重更新
  对于 i = 1, ..., N:
    w_t^(i) ∝ w_{t-1}^(i) p(z_t | x_t^(i))
  
  # 归一化权重
  w_t^(i) = w_t^(i) / Σ_j w_t^(j)
  
  # 状态估计
  x̂_t = Σ_i w_t^(i) x_t^(i)
  
  # 重采样（如果需要）
  if N_eff < N_threshold:
    {x_t^(i), w_t^(i)} = resample({x_t^(i), w_t^(i)})
```

---

## 4. 实现

```python
import numpy as np

class ParticleFilter:
    """粒子滤波器"""
    
    def __init__(self, N, f, h, Q, R, x0_sampler):
        """
        参数:
            N: 粒子数量
            f: 状态转移函数
            h: 观测函数
            Q: 过程噪声协方差
            R: 观测噪声协方差
            x0_sampler: 初始状态采样函数
        """
        self.N = N
        self.f = f
        self.h = h
        self.Q = Q
        self.R = R
        
        # 初始化粒子
        self.particles = np.array([x0_sampler() for _ in range(N)])
        self.weights = np.ones(N) / N
    
    def predict(self):
        """预测步骤"""
        for i in range(self.N):
            # 状态转移 + 过程噪声
            noise = np.random.multivariate_normal(np.zeros(len(self.Q)), self.Q)
            self.particles[i] = self.f(self.particles[i]) + noise
    
    def update(self, z):
        """更新步骤"""
        for i in range(self.N):
            # 计算似然
            z_pred = self.h(self.particles[i])
            diff = z - z_pred
            
            # 高斯似然
            likelihood = np.exp(-0.5 * diff.T @ np.linalg.inv(self.R) @ diff)
            likelihood /= np.sqrt((2*np.pi)**len(z) * np.linalg.det(self.R))
            
            # 更新权重
            self.weights[i] *= likelihood
        
        # 归一化权重
        self.weights += 1e-300  # 避免除零
        self.weights /= np.sum(self.weights)
    
    def resample(self):
        """重采样"""
        # 计算有效粒子数
        N_eff = 1.0 / np.sum(self.weights**2)
        
        if N_eff < self.N / 2:
            # 系统重采样
            indices = self.systematic_resample()
            self.particles = self.particles[indices]
            self.weights = np.ones(self.N) / self.N
    
    def systematic_resample(self):
        """系统重采样"""
        N = self.N
        positions = (np.arange(N) + np.random.random()) / N
        
        indices = np.zeros(N, dtype=int)
        cumsum = np.cumsum(self.weights)
        
        i, j = 0, 0
        while i < N:
            if positions[i] < cumsum[j]:
                indices[i] = j
                i += 1
            else:
                j += 1
        
        return indices
    
    def estimate(self):
        """状态估计"""
        return np.average(self.particles, weights=self.weights, axis=0)
    
    def step(self, z):
        """完整步骤"""
        self.predict()
        self.update(z)
        self.resample()
        return self.estimate()


# 使用示例
def particle_filter_example():
    """粒子滤波示例"""
    
    # 参数
    N = 1000  # 粒子数
    dt = 0.1
    
    # 状态转移函数
    def f(x):
        F = np.array([[1, 0, dt, 0],
                      [0, 1, 0, dt],
                      [0, 0, 1, 0],
                      [0, 0, 0, 1]])
        return F @ x
    
    # 观测函数
    def h(x):
        return x[:2]  # 观测位置
    
    # 噪声协方差
    Q = 0.1 * np.eye(4)
    R = 0.5 * np.eye(2)
    
    # 初始采样
    def x0_sampler():
        return np.random.multivariate_normal([0, 0, 1, 0.5], np.diag([1, 1, 0.5, 0.5]))
    
    # 创建滤波器
    pf = ParticleFilter(N, f, h, Q, R, x0_sampler)
    
    # 模拟追踪
    T = 100
    x_est = np.zeros((4, T))
    
    for t in range(T):
        # 生成观测（这里简化，实际应从真实轨迹生成）
        z = np.array([t*dt, 0.5*t*dt]) + np.random.multivariate_normal([0, 0], R)
        
        # 滤波
        x_est[:, t] = pf.step(z)
    
    return x_est

# x_est = particle_filter_example()
```

---

## 5. 重采样方法

### 5.1 多项式重采样
最简单，但方差大

### 5.2 系统重采样
方差小，计算高效

### 5.3 残差重采样
保留高权重粒子

---

## 6. 优缺点

**优点**：
- 处理任意非线性非高斯
- 理论简单
- 易于并行化

**缺点**：
- 计算量大
- 粒子退化问题
- 高维状态空间困难

---

## 7. 改进方法

### 7.1 辅助粒子滤波 (APF)
预先评估粒子质量

### 7.2 正则化粒子滤波 (RPF)
添加核密度估计

### 7.3 Rao-Blackwellized PF
部分状态解析求解

---

## 参考文献

1. Arulampalam, M. S., et al. (2002). "A tutorial on particle filters." IEEE TSP.

2. Doucet, A., & Johansen, A. M. (2009). "A tutorial on particle filtering and smoothing." Handbook of Nonlinear Filtering.
