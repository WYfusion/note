# 卡尔曼滤波

## 1. 概述

**卡尔曼滤波 (Kalman Filter, KF)** 是线性高斯系统的最优贝叶斯滤波器，在说话人追踪中广泛应用。

### 1.1 历史

- 1960年由Rudolf Kalman提出
- 首次应用于阿波罗登月计划
- 现代控制理论的基石

### 1.2 最优性

在以下条件下，KF是MMSE意义下的最优估计器：
- 线性系统
- 高斯噪声
- 已知模型参数

---

## 2. 系统模型

### 2.1 状态空间表示

**状态方程**：
$$\mathbf{x}_t = \mathbf{F}_t \mathbf{x}_{t-1} + \mathbf{B}_t \mathbf{u}_t + \mathbf{w}_t$$

**观测方程**：
$$\mathbf{z}_t = \mathbf{H}_t \mathbf{x}_t + \mathbf{v}_t$$

**噪声假设**：
$$\mathbf{w}_t \sim \mathcal{N}(\mathbf{0}, \mathbf{Q}_t)$$
$$\mathbf{v}_t \sim \mathcal{N}(\mathbf{0}, \mathbf{R}_t)$$

### 2.2 说话人追踪模型

**2D匀速运动**：

状态：$\mathbf{x}_t = [x_t, y_t, \dot{x}_t, \dot{y}_t]^T$

$$\mathbf{F} = \begin{bmatrix} 1 & 0 & \Delta t & 0 \\ 0 & 1 & 0 & \Delta t \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix}$$

$$\mathbf{H} = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \end{bmatrix}$$

---

## 3. 卡尔曼滤波算法

### 3.1 预测步骤

**状态预测**：
$$\hat{\mathbf{x}}_{t|t-1} = \mathbf{F}_t \hat{\mathbf{x}}_{t-1|t-1} + \mathbf{B}_t \mathbf{u}_t$$

**协方差预测**：
$$\mathbf{P}_{t|t-1} = \mathbf{F}_t \mathbf{P}_{t-1|t-1} \mathbf{F}_t^T + \mathbf{Q}_t$$

### 3.2 更新步骤

**卡尔曼增益**：
$$\mathbf{K}_t = \mathbf{P}_{t|t-1} \mathbf{H}_t^T (\mathbf{H}_t \mathbf{P}_{t|t-1} \mathbf{H}_t^T + \mathbf{R}_t)^{-1}$$

**状态更新**：
$$\hat{\mathbf{x}}_{t|t} = \hat{\mathbf{x}}_{t|t-1} + \mathbf{K}_t (\mathbf{z}_t - \mathbf{H}_t \hat{\mathbf{x}}_{t|t-1})$$

**协方差更新**：
$$\mathbf{P}_{t|t} = (\mathbf{I} - \mathbf{K}_t \mathbf{H}_t) \mathbf{P}_{t|t-1}$$

### 3.3 完整算法

```
输入: z_1, z_2, ..., z_T
输出: x̂_1, x̂_2, ..., x̂_T

初始化:
  x̂_0|0 = x̂_0
  P_0|0 = P_0

对于 t = 1, 2, ..., T:
  # 预测
  x̂_t|t-1 = F_t x̂_t-1|t-1
  P_t|t-1 = F_t P_t-1|t-1 F_t^T + Q_t
  
  # 更新
  K_t = P_t|t-1 H_t^T (H_t P_t|t-1 H_t^T + R_t)^{-1}
  x̂_t|t = x̂_t|t-1 + K_t (z_t - H_t x̂_t|t-1)
  P_t|t = (I - K_t H_t) P_t|t-1
```

---

## 4. 数学推导

### 4.1 预测推导

**状态预测**：
$$\hat{\mathbf{x}}_{t|t-1} = \mathbb{E}[\mathbf{x}_t | \mathbf{z}_{1:t-1}]$$
$$= \mathbb{E}[\mathbf{F}_t \mathbf{x}_{t-1} + \mathbf{w}_t | \mathbf{z}_{1:t-1}]$$
$$= \mathbf{F}_t \mathbb{E}[\mathbf{x}_{t-1} | \mathbf{z}_{1:t-1}]$$
$$= \mathbf{F}_t \hat{\mathbf{x}}_{t-1|t-1}$$

**协方差预测**：
$$\mathbf{P}_{t|t-1} = \mathbb{E}[(\mathbf{x}_t - \hat{\mathbf{x}}_{t|t-1})(\mathbf{x}_t - \hat{\mathbf{x}}_{t|t-1})^T]$$
$$= \mathbf{F}_t \mathbf{P}_{t-1|t-1} \mathbf{F}_t^T + \mathbf{Q}_t$$

### 4.2 更新推导

**最小化代价函数**：
$$J = (\mathbf{x}_t - \hat{\mathbf{x}}_{t|t-1})^T \mathbf{P}_{t|t-1}^{-1} (\mathbf{x}_t - \hat{\mathbf{x}}_{t|t-1}) + (\mathbf{z}_t - \mathbf{H}_t \mathbf{x}_t)^T \mathbf{R}_t^{-1} (\mathbf{z}_t - \mathbf{H}_t \mathbf{x}_t)$$

求导并令其为零，得到卡尔曼增益和更新公式。

---

## 5. 实现

```python
import numpy as np

class KalmanFilter:
    """卡尔曼滤波器实现"""
    
    def __init__(self, F, H, Q, R, x0, P0):
        """
        参数:
            F: 状态转移矩阵
            H: 观测矩阵
            Q: 过程噪声协方差
            R: 观测噪声协方差
            x0: 初始状态
            P0: 初始协方差
        """
        self.F = F
        self.H = H
        self.Q = Q
        self.R = R
        
        self.x = x0
        self.P = P0
        
        self.n_x = len(x0)
        self.n_z = H.shape[0]
    
    def predict(self, u=None):
        """预测步骤"""
        # 状态预测
        self.x = self.F @ self.x
        if u is not None:
            self.x += self.B @ u
        
        # 协方差预测
        self.P = self.F @ self.P @ self.F.T + self.Q
        
        return self.x, self.P
    
    def update(self, z):
        """更新步骤"""
        # 创新
        y = z - self.H @ self.x
        
        # 创新协方差
        S = self.H @ self.P @ self.H.T + self.R
        
        # 卡尔曼增益
        K = self.P @ self.H.T @ np.linalg.inv(S)
        
        # 状态更新
        self.x = self.x + K @ y
        
        # 协方差更新（Joseph形式，数值稳定）
        I_KH = np.eye(self.n_x) - K @ self.H
        self.P = I_KH @ self.P @ I_KH.T + K @ self.R @ K.T
        
        return self.x, self.P
    
    def step(self, z, u=None):
        """完整的预测-更新步骤"""
        self.predict(u)
        self.update(z)
        return self.x, self.P


def speaker_tracking_example():
    """说话人追踪示例"""
    
    # 参数设置
    dt = 0.1  # 采样间隔
    T = 100   # 时间步数
    
    # 状态转移矩阵（匀速模型）
    F = np.array([
        [1, 0, dt, 0],
        [0, 1, 0, dt],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ])
    
    # 观测矩阵（位置观测）
    H = np.array([
        [1, 0, 0, 0],
        [0, 1, 0, 0]
    ])
    
    # 过程噪声协方差
    q = 0.1
    Q = q * np.array([
        [dt**3/3, 0, dt**2/2, 0],
        [0, dt**3/3, 0, dt**2/2],
        [dt**2/2, 0, dt, 0],
        [0, dt**2/2, 0, dt]
    ])
    
    # 观测噪声协方差
    R = 0.5 * np.eye(2)
    
    # 初始状态
    x0 = np.array([0, 0, 1, 0.5])
    P0 = np.diag([1, 1, 0.5, 0.5])
    
    # 创建滤波器
    kf = KalmanFilter(F, H, Q, R, x0, P0)
    
    # 生成真实轨迹
    x_true = np.zeros((4, T))
    z_obs = np.zeros((2, T))
    x_true[:, 0] = x0
    
    for t in range(1, T):
        w = np.random.multivariate_normal(np.zeros(4), Q)
        x_true[:, t] = F @ x_true[:, t-1] + w
        
        v = np.random.multivariate_normal(np.zeros(2), R)
        z_obs[:, t] = H @ x_true[:, t] + v
    
    # 滤波
    x_est = np.zeros((4, T))
    x_est[:, 0] = x0
    
    for t in range(1, T):
        x_est[:, t], _ = kf.step(z_obs[:, t])
    
    # 计算误差
    pos_error = np.sqrt((x_true[0, :] - x_est[0, :])**2 + 
                        (x_true[1, :] - x_est[1, :])**2)
    
    print(f"平均位置误差: {np.mean(pos_error):.3f} m")
    print(f"最大位置误差: {np.max(pos_error):.3f} m")
    
    return x_true, z_obs, x_est

# x_true, z_obs, x_est = speaker_tracking_example()
```

---

## 6. 性能分析

### 6.1 稳态卡尔曼滤波

当系统参数不变时，协方差会收敛到稳态值：
$$\mathbf{P}_{\infty} = \lim_{t \to \infty} \mathbf{P}_t$$

可通过求解代数Riccati方程获得。

### 6.2 可观测性

系统可观测的充要条件：
$$\text{rank}\begin{bmatrix} \mathbf{H} \\ \mathbf{H}\mathbf{F} \\ \vdots \\ \mathbf{H}\mathbf{F}^{n-1} \end{bmatrix} = n$$

### 6.3 可控性

系统可控的充要条件：
$$\text{rank}[\mathbf{Q}^{1/2}, \mathbf{F}\mathbf{Q}^{1/2}, \ldots, \mathbf{F}^{n-1}\mathbf{Q}^{1/2}] = n$$

---

## 7. 实际应用技巧

### 7.1 参数调优

**Q矩阵调优**：
- 增大Q：更信任观测
- 减小Q：更信任模型

**R矩阵调优**：
- 增大R：更信任模型
- 减小R：更信任观测

### 7.2 数值稳定性

**Joseph形式协方差更新**：
$$\mathbf{P}_t = (\mathbf{I} - \mathbf{K}_t \mathbf{H}_t) \mathbf{P}_{t|t-1} (\mathbf{I} - \mathbf{K}_t \mathbf{H}_t)^T + \mathbf{K}_t \mathbf{R}_t \mathbf{K}_t^T$$

保证协方差矩阵正定。

### 7.3 缺失观测处理

当观测缺失时，只执行预测步骤：
```python
if observation_available:
    kf.update(z)
else:
    # 只预测，不更新
    pass
```

---

## 8. 总结

**优点**：
- 计算高效
- 理论最优
- 易于实现

**缺点**：
- 仅适用于线性系统
- 需要高斯假设
- 对模型误差敏感

**适用场景**：
- 匀速或匀加速运动
- 高斯噪声环境
- 实时处理要求

---

## 参考文献

1. Kalman, R. E. (1960). "A new approach to linear filtering and prediction problems." Journal of Basic Engineering.

2. Welch, G., & Bishop, G. (2006). "An introduction to the Kalman filter." UNC-Chapel Hill, TR 95-041.
