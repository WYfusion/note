常规卷积的`padding`参数定义为**单侧填充量**，即：
- 左侧填充 `padding` 个 0；
- 右侧填充 `padding` 个 0；
- 总填充量为 `2×padding`
注意，因果卷积的填充比较特殊，其是将常规卷积算得的左右两边的填充都放置于左侧进行填充了，实际计算因果卷积的填充时可以先两倍计算常规卷积的零填充值，然后分别在两边进行常规填充，最后对于所计算的两倍填充后的数据裁掉后面的两倍填充。这里所述的常规卷积两倍填充值就是因果卷积的实际填充计算值。最后实现的效果是因果卷积必须 “只左填、不右填”。
这种 “对称填充” 的目的是**平衡输入序列两端的信息损失**（避免左侧边缘和右侧边缘的特征被卷积核 “截断” 的程度不同）
实际应用中，padding 的设置通常是为了得到预期的输出长度（如 “same padding” 要求**输出长度 = 输入长度**）。以下以 “same padding”（最常用场景）为例推导：
## 场景 1：无膨胀（dilation=1），步长 stride=1
目标：输出长度 = 输入长度（`output_len = input_len`）。代入核心公式[[常规卷积#^5d572d]]：
$$\text{output\_len} = \left\lfloor \frac{\text{input\_len} + 2 \times \text{padding} - 1 \times (k - 1) - 1}{1} \right\rfloor + 1$$

化简有
$$\texttt{output\_len} = (\text{input\_len} + 2 \times \text{padding} - k) + 1$$
明显有：$0 = 2 \times \text{padding} - k + 1 \implies \text{padding} = \frac{k - 1}{2}$
这是最常见的 same padding 公式（如`kernel_size=3`时，`padding=1`；`kernel_size=5`时，`padding=2`），显然是左右对称填充（各填 1 或 2 个 0）。
## 场景 2：有膨胀（dilation=d），步长 stride=1

目标仍为输出长度 = 输入长度：代入核心公式[[常规卷积#^5d572d]]：
$$\text{output\_len} = \left\lfloor \frac{\text{input\_len} + 2 \times \text{padding} - d \times (k - 1) - 1}{1} \right\rfloor + 1$$

化简有推得
$$ \text{padding} = \frac{d \times (k - 1)}{2}$$
## 场景 3：步长 stride>1（如 stride=2）

若希望输出长度 = 输入长度 / 2（下采样一倍），代入公式：
$$\frac{\text{input\_len}}{2} = \left\lfloor \frac{\text{input\_len} + 2 \times \text{padding} - d \times (k - 1) - 1}{2} \right\rfloor + 1$$
化简（忽略取整）：$$\text{input\_len} = \text{input\_len} + 2 \times \text{padding} - d(k-1) - 1 + 2$$
$$0 = 2 \times \text{padding} - d(k-1) + 1 \implies \text{padding} = \frac{d(k-1) - 1}{2}$$

总之关于填充的大小计算需要依赖于输入和输出维度长度的关系。先明确 “希望输出多长”，再用核心公式反推 padding



