# 创建并运行
## docker run
`docker run` 命令的主要作用是创建并启动一个新的容器。它的基本语法如下：
```bash
docker run [options] images [command] [arg...]
```
- `options`：这是一系列可选参数，用来对容器的各种行为进行配置。
- `images`：表示要使用的镜像名称或者 ID。
- `command` 和 `arg`：是在容器启动时要执行的命令及其参数。
#### 常用的 `options` 参数
- `-d`：以守护进程（后台）模式运行容器。
- `-p`：将容器的端口映射到宿主机的端口，格式为 `-p <宿主机端口>:<容器端口>/<协议>`。
    - **映射多个不连续端口**：直接写多个 `-p` 参数即可。
      ```bash
      -p 8888:8888 -p 2222:22 -p 6006:6006
      ```
    - 单个端口: -p 8888:8888
    - 端口范围: -p 9000-9010:9000-9010
    - 指定协议: -p 8888:8888/tcp 或 -p 5353:5353/udp
    - 指定接口: -p 127.0.0.1:8888:8888 (仅本地访问)
    - 随机端口: -p 127.0.0.1::8888 (随机映射主机端口)
- `-v`：将宿主机的目录挂载到容器内，格式为 `-v <宿主机路径>:<容器路径>:<选项>`。
    - **挂载多个目录**：直接写多个 `-v` 参数即可。
      ```bash
      -v /home/user/data:/data -v /home/user/code:/app
      ```
    - :ro - 只读挂载
    - :rw - 读写挂载(默认)
    - :z - 共享SELinux标签
    - :Z - 私有SELinux标签
- `-e`：设置环境变量，格式为 `变量名=变量值`。
- `-i`: 保持STDIN开放
- `-t`: 分配一个伪终端
- `--name`：为容器指定一个自定义的名称。
- `--gpus`: 为容器设置所使用的GPU，
    - `--gpus "device=0,1"` :仅使用第0和第1号GPU；
    - `--gpus all`使用全部GPU
- `--shm-size`: 设置容器的共享内存大小，多个计算进程可通过共享内存快速交换中间计算结果。减少了因数据复制产生的系统调用，节省 CPU 资源。
    - `--shm-size=8g`分配了8GB共享内存。默认64MB

### 深入理解 [command] (启动命令)
`[command]` 并不是 Docker 的特殊指令，它本质上是**容器内部文件系统里的任何可执行程序**。

**1. 它可以是什么？**
只要是镜像里安装了的软件，都可以作为 Command 运行。
- **Shell**: `/bin/bash`, `/bin/sh` (最常用，用于进入终端)
- **系统工具**: `ls -l`, `top`, `nvidia-smi`, `cat /etc/os-release`
- **应用程序**: `python train.py`, `jupyter notebook`, `ollama run xxx`

**2. 由什么决定？**
- **镜像内容**: 构建镜像时 (`Dockerfile`) 装了什么。例如 `pytorch` 镜像里有 `python`，但可能没有 `vim`。
- **环境变量 PATH**: 容器内的 `PATH` 决定了可以直接敲哪些命令（而不用写绝对路径 `/usr/bin/python`）。

**3. 示例对比**
- **交互模式 (进入容器)**:
  ```bash
  docker run -it ubuntu /bin/bash
  ```
  *解释：启动 ubuntu，并运行 bash 程序，配合 -it 让你能和它对话。*

- **一次性任务 (跑完即焚)**:
  ```bash
  docker run --rm ubuntu echo "Hello World"
  ```
  *解释：启动 ubuntu，运行 echo 程序，打印完立刻退出容器。*

##### 示例
- **Windows (PowerShell)**：以交互模式启动一个基于 cuda11.8-cudnn8 镜像的容器：
```powershell
docker run --gpus all -it `
  -p 8888:8888 -p 6006:6006 -p 2222:22 `
  -v "${PWD}:/workspace" `
  -v "D:\Datasets:/data" `
  --name my_dl_container `
  deeplearning:cuda11.8-cudnn8 `
  bash
```
其中的 `deeplearning:cuda11.8-cudnn8` 是镜像和标签
*注意：PowerShell 使用反引号 `` ` `` 换行，路径建议加引号。*

- **Linux (Bash)**：同样的命令，语法略有不同：
```bash
docker run --gpus all -it \
  -p 8888:8888 -p 6006:6006 -p 2222:22 \
  -v $(pwd):/workspace \
  -v /home/user/datasets:/data \
  --name my_dl_container \
  deeplearning:cuda11.8-cudnn8 \
  bash
```
*注意：Linux 使用反斜杠 `\` 换行，路径通常不需要引号（除非有空格）。*

在这个命令中，`-it` 选项开启了交互模式，允许你和容器进行交互。`bash` 是在容器启动时执行的命令，它会打开一个 Bash 终端。`$(pwd)`命令是获取当前工作路径并替换。
- Windows注意事项：
    - 在PowerShell中应使用`${PWD}`
    - 在CMD中应使用`%cd%`
## 仅创建容器
```bash
docker create --gpus all -it \
  -p 8888:8888 -p 6006:6006 -p 8080:80 \
  -v $(pwd):/workspace \
  --name my_dl_container \
  deeplearning:cuda11.8-cudnn8
```

## 基本容器命令
#### 查看正在使用的容器
```bash
docker ps
```

#### 查看全部的容器
```bash
docker ps -a
```

## 文件拷贝 (docker cp)
`docker cp` 用于在容器和宿主机之间复制文件或目录。这在忘记挂载卷时，或者需要临时提取训练好的模型权重/日志时非常有用。

```bash
# 从容器复制到宿主机
docker cp [options] container:src_path dest_path

# 从宿主机复制到容器
docker cp [options] src_path container:dest_path
```

#### 示例
- 将训练好的模型权重从容器复制出来：
```bash
docker cp my_dl_container:/workspace/checkpoints/best_model.pth ./checkpoints/
```

- 将本地的数据集补充文件复制进容器：
```bash
docker cp ./new_data.csv my_dl_container:/workspace/data/
```

### 核心辨析：挂载 (-v) vs 拷贝 (cp)
这是深度学习环境中最常混淆的两个操作。

| 特性 | 挂载 (`-v`) | 拷贝 (`docker cp`) |
| :--- | :--- | :--- |
| **本质** | **映射 (Mapping)** | **复制 (Copy)** |
| **数据同步** | 实时同步 (双向) | 不同步 (一次性快照) |
| **持久性** | 容器删除后，宿主机文件保留 | 容器删除后，容器内文件丢失 |
| **适用场景** | **数据集、代码开发、训练日志** | **临时提取模型、抢救日志、注入临时文件** |

> **最佳实践工作流**：
> 1. **构建时 (Build)**：在 `.dockerignore` 中忽略 `data/` 和 `weights/`，防止镜像体积爆炸（几十 GB 的镜像无法分发）。
> 2. **运行时 (Run)**：使用 `-v /host/data:/app/data` 将它们挂载进去。
>
> **口诀：代码进镜像，数据走挂载；临时取文件，才用 cp 拷。**

#### 进入容器 (docker exec)
`docker exec` 的本质是在**已经运行的容器中**启动一个新的进程。

> [!warning] 注意
> 1. 端口映射必须在`docker run`或`docker create`时设置
> 2. 运行的容器不能通过`docker exec`添加端口映射

**常用用法 1：进入交互式终端**
这是最常见的用法，启动 `bash` 让你像用虚拟机一样操作容器。
```bash
docker exec -it [containerID] bash
```

**常用用法 2：直接执行命令 (不进入终端)**
你不需要每次都先进去再敲命令，可以直接让容器执行特定程序。这在自动化脚本中非常有用。

- **示例 A：查看容器内的显卡状态**
  ```bash
  docker exec my_container nvidia-smi
  ```
  *这会直接打印显卡信息然后退出，不会卡在容器里。*

- **示例 B：在 Ollama 容器里下载模型**
  ```bash
  docker exec -it ollama-qwen3-coder30b ollama run qwen3-coder:30b
  ```
  *原理：这告诉 Docker 在容器里找 `ollama` 这个程序，并传给它参数 `run qwen3-coder:30b`。*
  *前提：容器里必须装了 `ollama` 且在 PATH 环境变量里。*
#### 删除指定容器
```bash
docker rm 
```
```bash
docker rm [containerID]
```

## 启动已停止的容器
`docker start` 命令用于启动之前已经停止运行的容器。其基本语法如下：
```bash
docker start [options] container [containerID...]
```
- `options`：可选参数，不过这个命令常用的可选参数较少。
- `container`：是要启动的容器的名称或者 ID。

#### 示例
- 启动名为 `my-container` 的容器：
```bash
docker start my-container
```
## 重启容器
`docker restart` 命令用于重启正在运行或者已经停止的容器。基本语法如下：
```bash
docker restart [options] container [containerID...]
```
- `options`：可选参数，例如 `--time` 可以指定在停止容器之前等待的秒数。
- `container`：要重启的容器的名称或者 ID。
###### 示例
- 重启名为 `my-container` 的容器：
```bash
docker restart my-container
```

## 启动多个容器

如果你想同时启动多个容器，可以在命令后面依次列出这些容器的名称或者 ID。例如：
```bash
docker start container1 container2 container3
```

此命令可以同时启动 `container1`、`container2` 和 `container3` 这三个容器。

## 启动容器时使用环境变量文件

在启动容器时，可以使用 `--env-file` 选项来指定一个包含环境变量的文件。假设你有一个名为 `env.list` 的文件，内容如下：
```plaintext
DB_HOST=localhost
DB_USER=root
DB_PASSWORD=password
```
你可以使用以下命令启动容器并加载这些环境变量：

```bash
docker run -d --env-file env.list myapp
```

在这个例子中，`myapp` 是要启动的容器所使用的镜像名称。

## 停止容器
`docker stop` 命令用于优雅地停止一个运行中的容器。它会向容器发送 SIGTERM 信号，等待一段时间（默认10秒）让进程保存状态，如果超时则发送 SIGKILL 强制杀死。

```bash
docker stop [options] container [containerID...]
```

#### 示例
- 停止训练容器（给模型保存 checkpoint 的机会）：
```bash
docker stop my_training_container
```

- 强制停止（立即发送 SIGKILL，等同于 `docker kill`）：
```bash
docker stop --time=0 my_training_container
```