# 清理与磁盘占用治理 (Prune)

## 适用场景
- 宿主机磁盘报警（Usage > 90%）。
- 频繁构建镜像导致产生大量 `<none>` 悬空镜像。
- 实验跑完后留下了大量停止的容器。

## 1. 磁盘分析 (`docker system df`)
在清理之前，先看看到底是谁占用了磁盘。

```bash
docker system df
```
输出示例：
```text
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          15        3         20.5GB    15.2GB (74%)
Containers      5         1         500MB     400MB (80%)
Local Volumes   2         1         100GB     0B (0%)
Build Cache     0         0         0B        0B
```
- **RECLAIMABLE**: 表示如果执行清理，能释放多少空间。

## 2. 推荐清理顺序 (由轻到重)

### 2.1 清理已停止的容器
实验跑完了，容器状态变成了 Exited，但文件系统层还在。
```bash
docker container prune
```

### 2.2 清理悬空镜像 (Dangling Images)
构建新镜像时，旧的同名镜像变成了 `<none>:<none>`。这些通常是无用的。
```bash
docker image prune
```

### 2.3 清理未使用的网络
```bash
docker network prune
```

## 3. 核弹级清理 (`docker system prune`)
这是一个组合命令，默认清理：
- 已停止的容器
- 悬空镜像 (Dangling)
- 未使用的网络
- 构建缓存

```bash
docker system prune
```

### 深度清理 (慎用!)
如果你想删除**所有未被运行容器使用的镜像**（不仅仅是悬空的），加上 `-a`。
这会导致你下次跑任务时需要重新拉取基础镜像（如 pytorch/pytorch）。
```bash
docker system prune -a
```

## 4. 风险提示：数据卷清理
> [!DANGER] 高危操作
> **`docker volume prune`** 会删除所有**未被挂载**的数据卷。
> 如果你的数据集或训练权重存在 Docker Volume 里，而当前没有容器挂载它，执行此命令会导致**数据永久丢失**。

**建议**：
- 除非你非常清楚自己在做什么，否则**不要**习惯性执行 `docker system prune --volumes`。
- 深度学习场景下，建议使用 **Bind Mount** (`-v /host/path:/container/path`) 而不是 Volume，这样数据在宿主机可见，不会被 Docker 误删。

## 5. 定期治理脚本
可以在 Crontab 中添加定时任务，每天凌晨清理悬空镜像（通常是安全的）：
```bash
# 每天凌晨 3 点清理悬空镜像
0 3 * * * docker image prune -f
```

