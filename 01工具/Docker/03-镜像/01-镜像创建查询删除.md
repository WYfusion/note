# 镜像创建

> 目标：理解 Docker 镜像的两种生成方式，并掌握标准构建流程。

## 适用场景
- 想把现有的容器保存下来（例如在容器里调通了复杂的深度学习环境）。
- 想通过 Dockerfile 自动化构建镜像（最常用）。
- 理解“上下文（Context）”是什么。

## 核心概念：镜像即“层（Layers）”
Docker 镜像不是一个单一文件，而是一组**只读**的层（Layer）。
- 每一层代表文件系统的一次修改（增加、删除、修改文件）。
- 容器启动时，会在镜像层最上面加一层**可写层**。

## 方法一：`docker commit`（黑盒构建）
> **注意**：不推荐用于生产环境！
> 缺点：不透明（不知道里面干了啥）、体积大、难以维护。
> 场景：临时保存现场、入侵取证、测试。

### 1. 启动一个容器并修改
```bash
# 启动一个 PyTorch 容器
docker run -it --name my-lab pytorch/pytorch:2.0.1-cuda11.7-cudnn8-runtime bash

# 在里面装个 matplotlib（修改了文件系统）
pip install matplotlib
exit
```

```bash
# 启动一个 ubuntu
docker run -it --name my-test ubuntu bash

# 在里面装个 vim（修改了文件系统）
apt-get update && apt-get install -y vim
exit
```

### 2. 提交为新镜像
这个方式可以将已经创建好、配置好的容器整合为镜像。
```bash
# 语法：docker commit [容器ID/名] [镜像名:Tag]
docker commit -m "installed matplotlib" my-lab my-pytorch:v1
```

### 3. 验证
```bash
docker images | grep my-pytorch
```

## 方法二：`docker build`（白盒构建，推荐）
> 基于 `Dockerfile` 描述构建步骤，可重复、可审计、体积可控。

### 1. 准备 Dockerfile
创建一个名为 `Dockerfile` 的文件：
```dockerfile
# 使用官方 PyTorch 镜像作为基础
FROM pytorch/pytorch:2.0.1-cuda11.7-cudnn8-runtime

# 设置工作目录
WORKDIR /workspace

# 安装依赖
RUN pip install matplotlib pandas

# 默认命令
CMD ["python"]
```

```dockerfile
FROM ubuntu:22.04
RUN apt-get update && apt-get install -y vim
CMD ["vim"]
```

### 2. 执行构建命令
**关键点**：请确保你的终端（Terminal）已经 `cd` 到了包含 `Dockerfile` 的那个目录。

```bash
# 语法：docker build [参数] [上下文路径]
# -t: 给镜像起个名字 (Tag)
# .:  代表“当前目录”，即告诉 Docker 使用当前目录下的文件作为构建上下文
docker build -t my-pytorch:v2 .
```

> [!TIP] 这里的 `.` 是什么？
> 它告诉 Docker：“去**当前目录**找 Dockerfile，并且把**当前目录**下的所有文件（除了 .dockerignore 里的）打包发给 Docker 引擎准备构建。”

## 常见报错：网络连接失败
如果你在构建时遇到如下错误：
```text
ERROR: failed to solve: failed to fetch oauth token: Post "https://auth.docker.io/token": ...
wsarecv: An existing connection was forcibly closed by the remote host.
```
**原因**：Docker 默认从 Docker Hub (国外) 拉取基础镜像，国内网络通常无法直接连接。
**解决**：需要配置 **Docker Registry Mirrors** (镜像加速器)。
1. 打开 Docker Desktop 设置 -> **Docker Engine**。
2. 修改 JSON 配置，增加 `registry-mirrors`：
   ```json
   {
     "builder": {
       "gc": {
         "defaultKeepStorage": "20GB",
         "enabled": true
       }
     },
     "experimental": false,
     "registry-mirrors": [
       "https://docker.m.daocloud.io",
       "https://huecker.io"
     ]
   }
   ```
3. 点击 **Apply & restart**。

## `docker build` 常用参数详解

### 1) `-t` / `--tag`（打标签）
给构建出来的镜像起名字。
```bash
# 格式：Repo:Tag
docker build -t my-dl-env:1.0 .
docker build -t my-dl-env:latest .
```

### 2) `-f` / `--file`（指定 Dockerfile）
如果你的文件不叫 `Dockerfile`，或者在子目录里。
```bash
docker build -f ./docker/Dockerfile.gpu -t my-dl-env:gpu .
```

### 3) `.`（构建上下文 Context）
**这是最容易被误解的参数！**
命令最后的 `.` 不是指“Dockerfile 所在目录”，而是指**构建上下文目录**。

- **原理**：Docker CLI 会把这个目录下的**所有文件**打包发送给 Docker Daemon。
- **坑点**：不要在根目录 `/` 或 `HOME` 目录执行 `docker build -t xxx .`，否则会把几十 GB 的硬盘数据（包括你的数据集、模型权重）发给 Daemon，导致构建极慢甚至卡死。

**正确做法**：
把 Dockerfile 和需要 COPY 的源码放在一个专门的目录里。

## .dockerignore（构建时的黑名单）
类似 `.gitignore`，告诉 Docker CLI 哪些文件**不要**发给 Daemon。
放在上下文根目录下。

**示例 `.dockerignore`**：
```text
.git
__pycache__
*.pyc
*.ipynb_checkpoints
# 忽略大数据集和模型权重
data/
weights/
*.pth
*.ckpt
```
**作用**：
1. **加速构建**：减少发送给 Daemon 的数据量。
2. **安全**：防止 `.env` 等敏感文件被意外 `COPY . .` 进镜像。

## 常用镜像管理命令
构建完镜像后，你可能需要查看、检查或清理它们。

### 1. 查看镜像 (`docker images`)
```bash
# 列出本地所有镜像
docker images

# 格式化输出 (只看名字和大小)
docker images --format "table {{.Repository}}:{{.Tag}}\t{{.Size}}"
```

### 2. 查看构建历史 (`docker history`)
**深度学习镜像优化神器**。
当你发现镜像体积高达 10GB+ 时，用这个命令查看**到底是哪一层**占用了空间。
```bash
docker history my-pytorch:v2
```
*输出示例：你会看到某一层 `RUN pip install ...` 占用了 2GB，或者 `COPY data/ ...` 占用了 5GB。*

### 3. 查看镜像详情 (`docker inspect`)
查看镜像的元数据（环境变量、启动命令、架构）。
```bash
# 查看镜像内定义的环境变量 (如 CUDA_VERSION)
docker inspect -f '{{range .Config.Env}}{{println .}}{{end}}' my-pytorch:v2
```

### 4. 删除镜像 (`docker rmi`)
```bash
# 删除指定 Tag
docker rmi my-pytorch:v2

# 强制删除 (即使有停止的容器在使用该镜像)
docker rmi -f my-pytorch:v2
```

## 总结
- 临时保存用 `commit`，正经干活必须用 `build`。
- 这里的 `.` 是上下文，别在盘符根目录跑。
- 善用 `.dockerignore` 忽略大数据集和模型权重。
