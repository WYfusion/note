# 镜像标签与版本策略 (Tag / Digest)

## 适用场景
- 生产环境部署，需要绝对的稳定性。
- 团队协作，需要明确的镜像版本规范。
- 避免“昨天还能跑，今天拉了新镜像就挂了”的惨剧。

## 核心概念：Tag vs Digest

### 1. Tag（标签）—— 可变引用
- 例子：`nginx:latest`, `python:3.9`, `pytorch:2.0.1-cuda11.7-cudnn8-runtime`
- **特点**：它是**可变**的。我可以今天把 `v1.0` 打在这个镜像上，明天发现 bug 修复了，又把 `v1.0` 打在另一个新镜像上。
- **风险**：你以为你部署的是同一个 `v1.0`，其实内容可能已经变了。

### 2. Digest（摘要）—— 不可变标识
- 例子：`pytorch@sha256:4c1c...`
- **特点**：它是基于镜像内容计算的哈希值。只要镜像内容有一丁点改变，Digest 就会变。
- **优势**：**绝对锁定**。部署时使用 Digest，可以保证任何时候拉下来的代码都是完全一样的。

## 警惕 `latest` 陷阱
> **黄金法则：生产环境永远不要用 `latest`！**

### 为什么？
1. **它不是“最新”**：`latest` 只是一个普通的字符串标签。如果维护者发布了新版本但忘了更新 `latest` 标签，它就不是最新的。
2. **不可控**：当你的 K8s 或 Docker Compose 自动重启容器时，如果拉取策略是 `Always`，它可能会拉到一个不兼容的大版本更新（比如从 PyTorch 1.x 突然跳到 2.x），导致代码报错。
3. **回滚困难**：你不知道上一次正常运行的 `latest` 到底对应哪个版本。

## 语义化版本 (SemVer) 策略
推荐使用 `主版本.次版本.修订号` (Major.Minor.Patch) 的格式。

### 推荐的打标签方式
构建一个版本时，同时打多个标签，方便不同需求的用户使用。

假设你发布了 `1.2.3` 版本：
```bash
docker build -t myapp:1.2.3 .
docker tag myapp:1.2.3 myapp:1.2  # 覆盖 1.2
docker tag myapp:1.2.3 myapp:1    # 覆盖 1
docker tag myapp:1.2.3 myapp:latest
```

### 深度学习镜像的命名规范
深度学习镜像通常依赖复杂的环境组合（CUDA, CuDNN, Python, PyTorch），建议把关键信息都写在 Tag 里。

**推荐格式**：
`{app_version}-cuda{cuda_ver}-cudnn{cudnn_ver}-{base_os}`

**示例**：
- `pytorch:2.0.1-cuda11.7-cudnn8-runtime`
- `tensorflow:2.12.0-gpu`
- `my-model:v1.0-torch2.0-cuda11.8`

### 用户如何选择？
- **追求稳定**：使用 `my-model:v1.0-torch2.0-cuda11.8`（锁定具体版本）。
- **接受小修补**：使用 `my-model:v1.0`（当有 v1.0.1 发布时会自动更新）。
- **激进更新**：使用 `my-model:latest`（仅限开发环境）。

## 镜像命名规范
完整的镜像名称结构如下：
```text
registry.example.com / my-group / my-project : v1.0.0
[------仓库地址------] [---组---] [--项目名--] [-Tag-]
```

- **Docker Hub 官方镜像**：`nginx:latest`其实是 `docker.io/library/nginx:latest`。
- **Docker Hub 用户镜像**：`username/project:tag`。
- **私有仓库**：必须带上域名，如 `harbor.company.com/ops/tools:v1`。

## 总结
1. 开发/测试可以用 Tag，生产建议用 Digest 或锁死的 Tag。
2. 严禁使用 `latest`。
3. 深度学习镜像 Tag 要包含 CUDA/PyTorch 版本信息。

