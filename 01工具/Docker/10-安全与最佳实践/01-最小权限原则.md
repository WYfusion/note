# 最小权限原则 (Docker Security)

## 适用场景
- 防止容器被黑客攻破后，直接获得宿主机的 Root 权限。
- 修复安全扫描出的 "Run as Root" 高危漏洞。

## 1. 为什么不要用 Root？
默认情况下，Docker 容器内的 `root` 用户 (UID 0) **就是宿主机的 root 用户**。
虽然有 Namespace 隔离，但如果内核有漏洞（如 Dirty Cow），攻击者可以逃逸出容器，直接控制宿主机。

## 2. 解决方案：非 Root 用户运行

### 方法 A: Dockerfile 中指定 (推荐)
在构建镜像时创建用户，并切换过去。

```dockerfile
FROM python:3.9-slim

# 1. 创建用户 (appuser, uid=1000)
RUN useradd -m -u 1000 appuser

# 2. 设置工作目录权限
WORKDIR /app
COPY . .
RUN chown -R appuser:appuser /app

# 3. 切换用户
USER appuser

# 4. 启动
CMD ["python", "app.py"]
```

### 方法 B: 运行时指定 (`--user`)
如果镜像里没创建用户，可以借用宿主机的用户 ID。

```bash
# 以当前用户的身份运行 (uid:gid)
docker run -u $(id -u):$(id -g) -v $(pwd):/app python:3.9 python app.py
```
*注意：这可能会导致容器内无法写入 `/root` 或 `/usr/local` 等系统目录，需要应用本身支持非 Root 运行。*

## 3. 限制系统能力 (Capabilities)
Linux Root 权限被拆分成了很多细粒度的 Capability。Docker 默认只开启了一部分。
**最佳实践**：关掉所有，只开需要的。

```bash
# 关掉所有能力，只开启网络绑定 (NET_BIND_SERVICE)
docker run --cap-drop=ALL --cap-add=NET_BIND_SERVICE nginx
```

## 4. 根目录只读 (`--read-only`)
防止攻击者修改容器内的二进制文件或植入后门。

```bash
docker run --read-only -v /tmp_data:/app/data my-app
```
*应用只能写入挂载的 Volume，无法修改 `/bin`, `/usr` 等系统目录。*

- `--security-opt no-new-privileges`

## TODO
- [ ] 给出一份“推荐 run 模版”
